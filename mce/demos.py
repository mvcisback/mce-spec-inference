__all__ = ['prefix_tree', 'PrefixTree']

import aiger_coins as C
import attr
import funcy as fn
import networkx as nx
from pyrsistent import pmap
from pyrsistent.typing import PMap

from mce.policy3 import BVPolicy
from mce.spec import ConcreteSpec
from mce.qbvnode import QBVNode


@attr.s(frozen=True, auto_attribs=True)
class PrefixTree:
    tree: nx.DiGraph
    root: str
    dyn: C.MDP

    def action(self, tnode1: str, tnode2: str):
        """Returns the action that transitioned tnode1 to tnode2."""
        return self.tree.edges[tnode1, tnode2]['action']

    def visits(self, tnode: str) -> int:
        """Returns the number of times this tree node was
        visited in the demonstrations."""
        return self.tree.nodes[tnode]['visits']

    @property
    def ndemos(self) -> int:
        """Number of demonstrations this prefix tree represents."""
        return self.visits(self.root)

    def _generate_product_edges(self, spec: ConcreteSpec):
        """Walk edges of the synchronous composition of the prefix
        tree and a concrete spec's bit-vector qdd."""
        # TODO: consider letting spec produce qbvnodes.
        order = spec.order
        qnode = spec._as_dfa(qdd=True).start

        qbv_root = QBVNode(qnode, order)
        stack = [(self.root, qbv_root)]
        while stack:
            tnode, qbv_node = stack.pop()
            for tnode2 in self.tree.neighbors(tnode):
                qbv_node2 = qbv_node.transition(self.action(tnode, tnode2))
                yield (tnode, qbv_node), (tnode2, qbv_node2)
                stack.append((tnode2, qbv_node2))

    def log_likelihood(self, ctrl: BVPolicy, actions_only=False) -> float:
        """Log likelihood that the demonstrations encoded into this
        prefix tree would have been generated by ctrl.

        If actions_only is True, then environment probabilities are
        ignore.  This is useful if comparing likelihoods of different
        controllers as the environment probabilities will cancel
        anyway and may require non-trivial additional computation.
        """
        if not actions_only:
            raise NotImplementedError

        def logp(edge):
            (tnode1, qbv_node), (tnode2, qbv_node2) = edge
            action, visits = self.action(tnode1, tnode2), self.visits(tnode2)

            if qbv_node.is_decision:
                return visits * ctrl.prob(qbv_node, action, log=True)
            return 0

        return sum(map(logp, self._generate_product_edges(ctrl.spec)))

    def psat(self, spec: ConcreteSpec):
        nodes = fn.pluck(1, self._generate_product_edges(spec))
        leaves = (x for x in nodes if x[1].qnode.label() is not None)
        sat_count = sum(self.visits(t)*q.qnode.label() for t, q in leaves)
        return sat_count / self.ndemos

    def write_dot(self, path):
        template = "{} = {}\n\ntime = {}   visits = {}\ncoins = {}"
        for node in self.tree.nodes:
            data = self.tree.nodes[node]
            data['label'] = template.format(
                "state" if data['decision'] else "action",
                dict(data['source']),
                data['visits'],
                data['time'],
                data.get('coins')
            )

        nx.nx_pydot.write_dot(self.tree, path)


def annotate(tree, root, dyn, trcs):
    for node in tree.nodes:
        tree.nodes[node]['visits'] = 0

    def advance(node, sym):
        for node2 in tree.neighbors(node):
            if sym == tree.nodes[node2]['source']:
                return node2

        raise RuntimeError

    for trc in trcs:
        node, prev_sym, state = root, None, None
        for i, sym in enumerate(trc):
            data = tree.nodes[node]
            data['visits'] += 1
            data['decision'] = (i % 2) == 0
            data['time'] = i // 2
            node = advance(node, sym)

        data = tree.nodes[node]
        data['visits'] += 1
        i += 1
        data['decision'] = (i % 2) == 0
        data['time'] = i // 2

    # Reuse precomputed coin flips
    find_env_input = fn.memoize(dyn.find_env_input)

    for edge in tree.edges:
        tnode1, tnode2 = edge
        if tree.nodes[tnode1]['decision']:
            payload = tree.nodes[tnode2]['source']
        else:
            action = pmap(tree.nodes[tnode1]['source'])
            end = pmap(tree.nodes[tnode2]['source'])
            assert tree.in_degree(tnode1) == 1
            tnode0, *_ = tree.predecessors(tnode1)
            start = pmap(tree.nodes[tnode0]['source'])
            payload = find_env_input(start, action, end)

        tree.edges[edge]['action'] = payload


def prefix_tree(dyn, trcs) -> PrefixTree:
    """Encodes i/o traces as sequences of (sys, env) actions."""
    trcs = [list(fn.interleave(*trc)) for trc in trcs]
    trcs = [fn.lmap(pmap, trc) for trc in trcs]

    tree, root = nx.prefix_tree(trcs)          # This tree has a dummy sink
    tree.remove_node(nx.generators.trees.NIL)  # which we don't want.
    tree.nodes[root]['source'] = pmap(dyn.aigbv.latch2init)

    annotate(tree, root, dyn, trcs)

    return PrefixTree(tree, root, dyn)
