__all__ = ['prefix_tree', 'PrefixTree']

import aiger_coins as C
import attr
import funcy as fn
import networkx as nx
import numpy as np
from pyrsistent import pmap
from pyrsistent.typing import PMap

from mce.policy3 import BVPolicy
from mce.spec import ConcreteSpec
from mce.qbvnode import QBVNode


@attr.s(frozen=True, auto_attribs=True)
class PrefixTree:
    tree: nx.DiGraph
    root: str
    dyn: C.MDP

    def action(self, tnode1: str, tnode2: str):
        """Returns the action that transitioned tnode1 to tnode2."""
        return self.tree.edges[tnode1, tnode2]['action']

    def visits(self, tnode: str) -> int:
        """Returns the number of times this tree node was
        visited in the demonstrations."""
        return self.tree.nodes[tnode]['visits']

    @property
    def ndemos(self) -> int:
        """Number of demonstrations this prefix tree represents."""
        return self.visits(self.root)

    def _generate_product_edges(self, spec: ConcreteSpec):
        """Walk edges of the synchronous composition of the prefix
        tree and a concrete spec's bit-vector qdd."""
        # TODO: consider letting spec produce qbvnodes.
        order = spec.order
        qnode = spec._as_dfa(qdd=True).start

        qbv_root = QBVNode(qnode, order)
        stack = [(self.root, qbv_root)]
        while stack:
            tnode, qbv_node = stack.pop()
            for tnode2 in self.tree.neighbors(tnode):
                qbv_node2 = qbv_node.transition(self.action(tnode, tnode2))
                yield (tnode, qbv_node), (tnode2, qbv_node2)
                stack.append((tnode2, qbv_node2))

    def log_likelihood(self, ctrl: BVPolicy, actions_only=False) -> float:
        """Log likelihood that the demonstrations encoded into this
        prefix tree would have been generated by ctrl.

        If actions_only is True, then environment probabilities are
        ignore.  This is useful if comparing likelihoods of different
        controllers as the environment probabilities will cancel
        anyway and may require non-trivial additional computation.
        """

        def logp(edge):
            (tnode1, qbv_node), (tnode2, qbv_node2) = edge
            visits = self.visits(tnode2)

            if qbv_node.is_decision:
                action = self.action(tnode1, tnode2)
                lprob = ctrl.prob(qbv_node, action, log=True)
            elif actions_only:
                lprob = 0
            else:
                action = self.tree.nodes[tnode1]['source']
                start = self.tree.nodes[tnode1]['state']
                end = self.tree.nodes[tnode2]['state']
                prob = self.dyn.prob(start, action, end)
                lprob = np.log(prob.numerator) - np.log(prob.denominator)
            return visits * lprob

        return sum(map(logp, self._generate_product_edges(ctrl.spec)))

    def psat(self, spec: ConcreteSpec):
        nodes = fn.pluck(1, self._generate_product_edges(spec))
        leaves = (x for x in nodes if x[1].qnode.label() is not None)
        sat_count = sum(self.visits(t)*q.qnode.label() for t, q in leaves)
        return sat_count / self.ndemos

    def write_dot(self, path):
        template = "decision = {}\n payload{}\n\n" \
            " time = {}   visits = {}\ncoins = {}\nstate={}"
        for node in self.tree.nodes:
            data = self.tree.nodes[node]
            data['label'] = template.format(
                data['decision'],
                dict(data['source']),
                data['visits'],
                data['time'],
                data.get('coins'),
                data.get('state'),
            )

        nx.nx_pydot.write_dot(self.tree, path)


def annotate(tree, root, dyn, trcs):
    for node in tree.nodes:
        tree.nodes[node]['visits'] = 0

    def advance(node, sym):
        for node2 in tree.neighbors(node):
            if sym == tree.nodes[node2]['source']:
                return node2

        raise RuntimeError

    for trc in trcs:
        node, prev_sym, state = root, None, None
        for i, sym in enumerate(trc):
            data = tree.nodes[node]
            data['visits'] += 1
            data['decision'] = (i % 2) == 0
            data['time'] = i // 2
            node = advance(node, sym)
            if data['decision']:
                state = data['state'] = data['source']
            else:
                data['state'] = state

        data = tree.nodes[node]
        data['visits'] += 1
        i += 1
        data['decision'] = (i % 2) == 0
        data['time'] = i // 2
        data['state'] = data['source']

    # Reuse precomputed coin flips
    find_env_input = fn.memoize(dyn.find_env_input)

    for edge in tree.edges:
        tnode1, tnode2 = edge
        if tree.nodes[tnode1]['decision']:
            payload = tree.nodes[tnode2]['source']
        else:
            action = pmap(tree.nodes[tnode1]['source'])
            start = pmap(tree.nodes[tnode1]['state'])
            end = pmap(tree.nodes[tnode2]['state'])
            payload = find_env_input(start, action, end)

        tree.edges[edge]['action'] = payload


def prefix_tree(dyn, trcs) -> PrefixTree:
    """Encodes i/o traces as sequences of (sys, env) actions."""
    trcs = [list(fn.interleave(*trc)) for trc in trcs]
    trcs = [fn.lmap(pmap, trc) for trc in trcs]

    tree, root = nx.prefix_tree(trcs)          # This tree has a dummy sink
    tree.remove_node(nx.generators.trees.NIL)  # which we don't want.
    tree.nodes[root]['source'] = pmap(dyn.aigbv.latch2init)

    annotate(tree, root, dyn, trcs)

    return PrefixTree(tree, root, dyn)
