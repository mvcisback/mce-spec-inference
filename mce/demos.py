__all__ = ['prefix_tree', 'PrefixTree']

import attr
import funcy as fn
import networkx as nx

from mce.policy3 import BVPolicy
from mce.spec import ConcreteSpec
from mce.qbvnode import QBVNode


@attr.s(frozen=True, auto_attribs=True)
class PrefixTree:
    tree: nx.DiGraph
    root: str

    def action(self, tnode: str):
        """Returns the action that lead to this tree node."""
        return self.tree.nodes[tnode]['source']

    def visits(self, tnode: str) -> int:
        """Returns the number of times this tree node was
        visited in the demonstrations."""
        return self.tree.nodes[tnode]['visits']

    @property
    def ndemos(self) -> int:
        """Number of demonstrations this prefix tree represents."""
        return self.visits(self.root)

    def _generate_product_edges(self, spec: ConcreteSpec):
        """Walk edges of the synchronous composition of the prefix
        tree and a concrete spec's bit-vector qdd."""
        # TODO: consider letting spec produce qbvnodes.
        order = spec.order
        qnode = spec._as_dfa(qdd=True).start

        qbv_root = QBVNode(qnode, order)
        stack = [(self.root, qbv_root)]
        while stack:
            tnode, qbv_node = stack.pop()
            for tnode2 in self.tree.neighbors(tnode):
                qbv_node2 = qbv_node.transition(self.action(tnode2))
                yield (tnode, qbv_node), (tnode2, qbv_node2)
                stack.append((tnode2, qbv_node2))

    def log_likelihood(self, ctrl: BVPolicy, actions_only=False) -> float:
        """Log likelihood that the demonstrations encoded into this
        prefix tree would have been generated by ctrl.

        If actions_only is True, then environment probabilities are
        ignore.  This is useful if comparing likelihoods of different
        controllers as the environment probabilities will cancel
        anyway and may require non-trivial additional computation.
        """
        if not actions_only:
            raise NotImplementedError

        def logp(edge):
            (_, qbv_node), (tnode2, qbv_node2) = edge
            action, visits = self.action(tnode2), self.visits(tnode2)

            if qbv_node.is_decision:
                return visits * ctrl.prob(qbv_node, action, log=True)
            return 0

        return sum(map(logp, self._generate_product_edges(ctrl.spec)))

    def psat(self, spec: ConcreteSpec):
        nodes = fn.pluck(1, self._generate_product_edges(spec))
        leaves = (x for x in nodes if x[1].qnode.label() is not None)
        sat_count = sum(self.visits(t)*q.qnode.label() for t, q in leaves)
        return sat_count / self.ndemos


def interleave(dyn, etrc):
    """
    1. Interleaves system and environment inputs.
    2. Makes dictionaries hashable for prefix tree.
    """
    for inputs in etrc:
        if dyn.inputs:
            yield tuple(fn.project(inputs, dyn.inputs).items())
        if dyn.env_inputs:
            yield tuple(fn.project(inputs, dyn.env_inputs).items())


def annotate_visits(tree, root, encoded):
    """Returns counter indicating how often each edge was
       visited in the demonstrations.
    """
    for node in tree.nodes:
        tree.nodes[node]['visits'] = 0

    def advance(node, sym):
        for node2 in tree.neighbors(node):
            if sym == tree.nodes[node2]['source']:
                return node2

        raise RuntimeError

    for etrc in encoded:
        curr = root
        for sym in etrc:
            tree.nodes[curr]['visits'] += 1
            curr = advance(curr, sym)
        tree.nodes[curr]['visits'] += 1


def prefix_tree(dyn, trcs) -> PrefixTree:
    """Encodes i/o traces as sequences of (sys, env) actions."""
    encoded = encode_trcs(dyn, trcs)
    encoded = [list(interleave(dyn, etrc)) for etrc in encoded]

    tree, root = nx.prefix_tree(encoded)       # This tree has a dummy sink
    tree.remove_node(nx.generators.trees.NIL)  # which we don't want.

    annotate_visits(tree, root, encoded)

    return PrefixTree(tree, root)


def encode_trcs(dyn, trcs):
    """Encodes i/o traces as sequences of (sys, env) actions."""
    return [_encode_trc(dyn, *v) for v in trcs]


def _encode_trc(dyn, sys_actions, states):
    return dyn.encode_trc(sys_actions, states)
